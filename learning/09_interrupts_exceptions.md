# 9. Interrupts and Exception Handling in x86-64

## Understanding Interrupts

Interrupts are signals sent to the processor to indicate an event that needs immediate attention. They can be:
- **Hardware Interrupts**: From external devices (keyboard, timer, etc.)
- **Software Interrupts**: Triggered by the `int` instruction
- **Exceptions**: Generated by the CPU for error conditions

## x86-64 Interrupt Architecture

### Interrupt Descriptor Table (IDT)
- Contains 256 entries (0-255)
- Each entry is 16 bytes
- Defines interrupt service routines (ISRs)

### IDT Entry Structure
```
struct idt_entry {
    uint16_t offset_low;    // Lower 16 bits of ISR address
    uint16_t selector;       // Code segment selector
    uint8_t ist;            // Interrupt Stack Table offset
    uint8_t type_attr;      // Type and attributes
    uint16_t offset_mid;    // Middle 16 bits of ISR address
    uint32_t offset_high;   // Upper 32 bits of ISR address
    uint32_t zero;          // Reserved (0)
} __attribute__((packed));
```

## Setting Up the IDT

### Define ISR Stubs
```assembly
%macro isr_noerr 1
isr%1:
    push 0                 ; Dummy error code
    push %1                ; Interrupt number
    jmp isr_common
%endmacro

%macro isr_err 1
isr%1:
    ; Error code pushed by CPU
    push %1                ; Interrupt number
    jmp isr_common
%endmacro

; Create ISR stubs
%assign i 0
%rep 256
    %if i == 8 || (i >= 10 && i <= 14) || i == 17 || i == 30
        isr_err i
    %else
        isr_noerr i
    %endif
    %assign i i+1
%endrep
```

### Common ISR Handler
```assembly
extern isr_handler  ; Defined in C

isr_common:
    ; Save all registers
    push rax
    push rcx
    push rdx
    push rbx
    push rbp
    push rsi
    push rdi
    push r8
    push r9
    push r10
    push r11
    push r12
    push r13
    push r14
    push r15
    
    ; Call C handler
    mov rdi, rsp    ; Pass pointer to registers
    call isr_handler
    
    ; Restore registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop r11
    pop r10
    pop r9
    pop r8
    pop rdi
    pop rsi
    pop rbp
    pop rbx
    pop rdx
    pop rcx
    pop rax
    
    ; Clean up error code and interrupt number
    add rsp, 16
    iretq
```

## Handling Specific Exceptions

### Page Fault Handler
```assembly
extern page_fault_handler

isr14:  ; Page Fault
    cli
    push rax
    
    ; Get CR2 (faulting address)
    mov rax, cr2
    push rax
    
    ; Call C handler with error code and fault address
    mov rdi, [rsp + 8]  ; Error code
    mov rsi, rax        ; Fault address
    call page_fault_handler
    
    ; Clean up and return
    pop rax
    pop rax
    sti
    iretq
```

## Programmable Interrupt Controller (PIC)

### Remapping the PIC
```assembly
; Initialize PIC
init_pic:
    ; Save registers
    push rax
    
    ; ICW1: Start initialization
    mov al, 0x11        ; ICW1 + ICW4 needed
    out 0x20, al        ; Send to master PIC
    out 0xA0, al        ; Send to slave PIC
    
    ; ICW2: Remap IRQ base
    mov al, 0x20        ; Master PIC vector offset = 0x20
    out 0x21, al
    mov al, 0x28        ; Slave PIC vector offset = 0x28
    out 0xA1, al
    
    ; ICW3: Master/Slave wiring
    mov al, 0x04        ; IRQ2 connects to slave
    out 0x21, al
    mov al, 0x02        ; Slave identity
    out 0xA1, al
    
    ; ICW4: 8086 mode
    mov al, 0x01
    out 0x21, al
    out 0xA1, al
    
    ; Mask all interrupts
    mov al, 0xFF
    out 0x21, al
    out 0xA1, al
    
    pop rax
    ret
```

## Advanced Interrupt Handling

### Interrupt Stack Frame
When an interrupt occurs, the CPU pushes:
1. SS:RSP (if privilege change)
2. RFLAGS
3. CS:RIP
4. Error code (for some exceptions)

### Nested Interrupts
```assembly
enable_interrupts:
    sti
    ret

disable_interrupts:
    cli
    ret

nested_isr:
    pushfq
    cli
    
    ; Save registers
    
    ; Handle interrupt
    
    ; Restore registers
    
    popfq
    iretq
```

## System Call Implementation

### Setting Up SYSCALL/SYSRET
```assembly
init_syscalls:
    ; Set STAR MSR (bits 47:32 = SYSRET CS, bits 31:16 = SYSCALL CS)
    mov ecx, 0xC0000081  ; STAR MSR
    rdmsr
    mov edx, 0x00180008  ; SYSRET CS = 0x18, SYSCALL CS = 0x08
    wrmsr
    
    ; Set LSTAR MSR to syscall entry point
    mov ecx, 0xC0000082  ; LSTAR MSR
    mov rdx, syscall_entry
    mov rax, rdx
    shr rdx, 32
    wrmsr
    
    ; Set FMASK MSR to clear interrupts and direction flag
    mov ecx, 0xC0000084  ; FMASK MSR
    mov eax, 0x00000300  ; Clear IF and DF
    xor edx, edx
    wrmsr
    
    ; Enable SYSCALL/SYSRET
    mov ecx, 0xC0000080  ; EFER MSR
    rdmsr
    or eax, 1            ; Set SCE bit
    wrmsr
    
    ret

syscall_entry:
    swapgs
    mov [gs:0x8], rsp    ; Save user stack
    mov rsp, [gs:0x0]    ; Load kernel stack
    
    ; Save registers
    push qword 0x1B      ; SS
    push qword [gs:0x8]   ; RSP
    push r11             ; RFLAGS
    push qword 0x23      ; CS
    push rcx             ; RIP
    
    ; Call syscall handler
    mov rdi, rax         ; syscall number
    mov rsi, [rsp + 8*7] ; arg1
    mov rdx, [rsp + 8*8] ; arg2
    mov r10, [rsp + 8*9] ; arg3
    mov r8, [rsp + 8*10] ; arg4
    mov r9, [rsp + 8*11] ; arg5
    
    call syscall_handler
    
    ; Restore registers
    pop rcx
    add rsp, 8           ; Skip CS
    pop r11              ; RFLAGS
    add rsp, 8           ; Skip RSP
    add rsp, 8           ; Skip SS
    
    ; Return to user mode
    swapgs
    o64 sysretq
```

## Exercises

1. **Basic Interrupt Handler**
   - Set up a simple IDT with handlers for common exceptions
   - Print an error message when a page fault occurs

2. **Keyboard Interrupt**
   - Write a handler for IRQ1 (keyboard)
   - Read scan codes from the keyboard controller
   - Convert scan codes to ASCII and display them

3. **System Call Interface**
   - Implement a simple system call interface using SYSCALL/SYSRET
   - Add system calls for basic I/O operations

## Best Practices

1. **Interrupt Safety**
   - Keep interrupt handlers short and fast
   - Disable interrupts only when necessary
   - Use lock-free data structures when possible

2. **Error Handling**
   - Always validate input in system calls
   - Provide meaningful error codes
   - Log errors for debugging

3. **Performance**
   - Batch operations when possible
   - Use interrupt coalescing for high-performance I/O
   - Consider using polling for low-latency requirements

In the next lesson, we'll explore mixed-language programming with C and assembly.
